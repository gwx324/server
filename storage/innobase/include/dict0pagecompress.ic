/*****************************************************************************

Copyright (c) 2013, 2016, MariaDB Corporation. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

*****************************************************************************/

/******************************************************************//**
@file include/dict0pagecompress.ic
Inline implementation for helper functions for extracting/storing
page compression and atomic writes information to dictionary.

Created 11/12/2013 Jan Lindstr√∂m jan.lindstrom@skysql.com
***********************************************************************/

/********************************************************************//**
Verify that dictionary flags match tablespace flags
@return	true if flags match, false if not */
UNIV_INLINE
ibool
dict_tf_verify_flags(
/*=================*/
	ulint	table_flags,	/*!< in: dict_table_t::flags */
	ulint   fsp_flags)      /*!< in: fil_space_t::flags  */
{
	ulint   table_unused = DICT_TF_GET_UNUSED(table_flags);
	ulint   compact = DICT_TF_GET_COMPACT(table_flags);
	ulint   ssize = DICT_TF_GET_ZIP_SSIZE(table_flags);
	ulint	atomic_blobs = DICT_TF_HAS_ATOMIC_BLOBS(table_flags);
	ulint   data_dir = DICT_TF_HAS_DATA_DIR(table_flags);
	ulint	post_antelope = FSP_FLAGS_GET_POST_ANTELOPE(fsp_flags);
	ulint	zip_ssize = FSP_FLAGS_GET_ZIP_SSIZE(fsp_flags);
	ulint	fsp_atomic_blobs = FSP_FLAGS_HAS_ATOMIC_BLOBS(fsp_flags);
	ulint	page_ssize = FSP_FLAGS_GET_PAGE_SSIZE(fsp_flags);
	ulint	fsp_unused = FSP_FLAGS_GET_UNUSED(fsp_flags);

	DBUG_EXECUTE_IF("dict_tf_verify_flags_failure",
			return(ULINT_UNDEFINED););

	ut_a(!table_unused);
	ut_a(!fsp_unused);
	ut_a(page_ssize == 0 || page_ssize != 0); /* silence compiler */
	ut_a(compact == 0 || compact == 1); /* silence compiler */
	ut_a(data_dir == 0 || data_dir == 1); /* silence compiler */
	ut_a(post_antelope == 0 || post_antelope == 1); /* silence compiler */

	if (ssize != zip_ssize) {
		fprintf(stderr,
			"InnoDB: Error: table flags has zip_ssize %ld"
			" in the data dictionary\n"
			"InnoDB: but the flags in file has zip_ssize %ld\n",
			ssize, zip_ssize);
		return (FALSE);
	}
	if (atomic_blobs != fsp_atomic_blobs) {
		fprintf(stderr,
			"InnoDB: Error: table flags has atomic_blobs %ld"
			" in the data dictionary\n"
			"InnoDB: but the flags in file has atomic_blobs %ld\n",
			atomic_blobs, fsp_atomic_blobs);

		return (FALSE);
	}

	return(TRUE);
}

/********************************************************************//**
Check whether the table uses the page compression page format.
@return	page compression level, or 0 if not compressed */
UNIV_INLINE
ulint
dict_table_page_compression_level(
/*==============================*/
	const dict_table_t*	table)	/*!< in: table */
{
	ut_ad(table);

	return(table->table_options->page_compression_level);
}

/********************************************************************//**
Check whether the table uses the page compression page format.
@return	true if page compressed, false if not */
UNIV_INLINE
ibool
dict_table_is_page_compressed(
/*==========================*/
	const dict_table_t* table)	/*!< in: table */
{
	ut_ad(table);

	return (table->table_options->page_compressed);
}
